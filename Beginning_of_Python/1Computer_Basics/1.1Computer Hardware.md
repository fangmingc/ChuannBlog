###  1.1 计算机硬件  
从概念上讲，一台简单的个人计算机可以抽象为类似下图的模型，**CPU**、**内存**以及**I/O设备**都由一条**系统总线(bus)** 连接起来并通过总线与其他设备通信，现代计算机的结构更复杂，包括**多重总线**。  
![](http://images2015.cnblogs.com/blog/1036857/201703/1036857-20170308232608125-1550495213.png) 
> I/O(input/output):读写  
计算机的工作原理：CPU读取指令->运算指令->输出结果。  
CPU从内存中读取指令进行运算，内存又是从磁盘中加载数据，当CPU运算完毕，把结果返回给内存，内存把结果存储在磁盘中。
#### 序
计算机的基础是**硬件**，从显示器到CPU都属于硬件，使用计算机本质上是操作计算机的这些硬件，但是计算机发展到今天，直接和硬件交流效率极其低下，就需要使用编程语言写一些指令集合来完成硬件的基础使用，将各个硬件基础使用的指令集合汇总起来就是操作系统，操作系统就承担了操作硬件的繁琐工作，使人有更多的精力注重如何使用编程语言编出更好的软件合理的使用硬件更好地完成工作。本质上，**操作系统**也是一种**软件**。
* 应用程序可以直接通过指令操作硬件，但是操作硬件的基础指令都是高重复性而且繁琐的，为了使应用程序能更大化的发挥作用，将不同程序的操作硬件的指令整合起来的就是操作系统，软件就可以只注重如何开发出更强大的功能而不必去因为如何操作硬件而烦恼。
> 计算机硬件（Computer hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。  
> 计算机由**运算器**、**控制器**、**存储器**、**输入设备**和**输出设备**等五个逻辑部件组成。通常把控制器与运算器合称为中央处理器（Central Processing Unit，CPU）
> >**运算器(Arithmetic Unit)** 由算术逻辑单元（ALU）、累加器、状态寄存器、通用寄存器组等组成。算术逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、求补等操作。计算机运行时，运算器的操作和操作种类由控制器决定。运算器处理的数据来自存储器；处理后的结果数据通常送回存储器，或暂时寄存在运算器中。  
> >**控制器(Control Unit)**，是整个计算机系统的控制中心，它指挥计算机各部分协调地工作，保证计算机按照预先规定的目标和步骤有条不紊地进行操作及处理。控制器从存储器中逐条取出指令，分析每条指令规定的是什么操作以及所需数据的存放位置等，然后根据分析的结果向计算机其它部件发出控制信号，统一指挥整个计算机完成指令所规定的操作。  
> >**存储器(Memory)** 是计算机系统中的记忆设备，用来存放程序和数据。计算机中全部信息，包括输入的原始数据、计算机程序、中间运行结果和最终运行结果都保存在存储器中。它根据控制器指定的位置存入和取出信息。  
> >**输入设备(Input Device)** 向计算机输入数据和信息的设备。是计算机与用户或其他设备通信的桥梁。输入设备是用户和计算机系统之间进行信息交换的主要装置之一。键盘，鼠标，摄像头，扫描仪，光笔，手写输入板，游戏杆，语音输入装置等都属于输入设备。  
> >**输出设备(Output Device)** 是计算机的终端设备，用于接收计算机数据的输出显示、打印、声音、控制外围设备操作等。也是把各种计算结果数据或信息以数字、字符、图像、声音等形式表示出来。
####  CPU  
计算用：
数学运算、逻辑运算
从存储介质取出指令，转换成可以运行的指令集（转码），然后运行  
(取指令->解码->运行)
#####  寄存器：
在实际的计算机中，与CPU直接相连接的是寄存器，寄存器存储了CPU运算的最关键的一些参数和指令，CPU需要运算的指令都是来自于寄存器。
寄存器与CPU的材质相同，运算速度最快（同CPU）。
######  通用寄存器
用来保存变量和临时结果的  
######  程序计数器
对程序员课件的专门寄存器之一，它保存了将要取出的下一条指令的内存地址。在指令取出后，程序计算器就被更新以便执行后期的指令
######  堆栈指针
对程序员课件的另外一个专门寄存器，它指向内存中当前栈的顶端。该栈包含已经进入但是还没有退出的每个过程中的一个框架。在一个过程的堆栈框架中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量

######  程序状态字寄存器(Program Status Word,PSW) 
包含了条码位(由比较指令设置)、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户通常读入整个**PSW**，但是只对其中少量的字段写入。在**系统调用**和**I/O**中，**PSW**非常非常非常非常非常非常重要
######  内核态与用户态
除了在嵌入式系统中的非常简答的CPU之外，多数CPU都有两种模式，即**内核态**与**用户态**。通常，PSW中有一个二进制位控制这两种模式。  
* CPU有两种状态，**内核态**、**用户态**，**内核态**指的是操作系统，**用户态**运行的是用户软件，但是用户软件也要操作硬件，所以需要从**用户态**切换到**内核态**，操作系统操作完硬件返回结果后还需要从**内核态**切换回**用户态**。  

* **内核态**与**用户态**切换　　**用户态**下工作的软件不能操作硬件，但是我们的软件比如暴风影音，一定会有操作硬件的需求，比如从磁盘上读一个电影文件，那就必须经历从**用户态**切换到**内核态**的过程，为此，用户程序必须使用系统调用（system call），系统调用切换到**内核态**并调用操作系统，TRAP指令把**用户态**切换成**内核态**，并启用操作系统从而获得服务。当操作完硬件之后，系统会切换到**用户态**，并将结果返回给用户程序。
> * **内核态**：当cpu在**内核态**运行时，cpu可以执行指令集中所有的指令，很明显，所有的指令中包含了使用硬件的所有功能，（操作系统在**内核态**下运行，从而可以访问整个硬件）  
> * **用户态**：用户程序在用户态下运行，仅仅只能执行cpu整个指令集的一个子集，该子集中不包含操作硬件功能的部分，因此，一般情况下，在用户态中有关I/O和内存保护（操作系统占用的内存是受保护的，不能被别的程序占用），当然，在**用户态**下，将PSW中的模式设置成**内核态**也是禁止的。  

#####  多线程和多核芯片

moore定律指出，芯片中的晶体管数量每18个月翻一倍，随着晶体管数量的增多，更强大的功能称为了可能，如

1.第一步增强：在cpu芯片中加入更大的缓存，一级缓存L1，用和cpu相同的材质制成，cpu访问它没有时延

2.第二步增强：一个cpu中的处理逻辑增多，intel公司首次提出，称为多线程（multithreading）或超线程（hyperthreading），对用户来说一个有两个线程的cpu就相当于两个cpu，我们后面要学习的进程和线程的知识就起源于这里，进程是资源单位而线程才是cpu的执行单位。

多线程运行cpu保持两个不同的线程状态，可以在纳秒级的时间内来回切换，速度快到你看到的结果是并发的，伪并行的，然而多线程不提供真正的并行处理，一个cpu同一时刻只能处理一个进程（一个进程中至少一个线程）

3.第三步增强：除了多线程，还出现了2个或者4个完整处理器的cpu芯片，如下图。要使用这类多核芯片肯定需要有多处理操作系统

![](http://images2015.cnblogs.com/blog/1036857/201701/1036857-20170118182512359-1757124963.png)
![](http://images2015.cnblogs.com/blog/1036857/201701/1036857-20170118182858218-1536914146.png)
####  存储器  
![](http://images2015.cnblogs.com/blog/1036857/201701/1036857-20170118183152312-1283265250.png)

理想的计算机应该是高速的读指令、高速的运算指令、高速的输出结果，但是这样的计算机极其稀少、造价高昂，远不能满足实际需求。而实际上，CPU也不能储存指令，需要一个存储设备来储存指令，CPU通过I/O接口连接到存储设备，I/O接口的读写速度就限制了CPU的运算速度，在实际的计算机中，与CPU直接相连接的是寄存器(L1缓存)，寄存器存储了CPU运算的最关键的一些参数和指令，同时次重要的数据就存放到了与寄存器相连的高速缓存(L2缓存)中，

#####  寄存器
即L1缓存：

用与cpu相同材质制造，与cpu一样快，因而cpu访问它无时延，典型容量是：在32位cpu中为32\*32，在64位cpu中为64\*64，在两种情况下容量均<1KB。

##### 高速缓存  
即L2缓存：

主要由硬件控制高速缓存的存取，内存中有高速缓存行按照0\~64字节为行0，64~127为行1。最常用的高速缓存行放置在cpu内部或者非常接近cpu的高速缓存中。当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。如果是，则称为高速缓存命中，缓存满足了请求，就不需要通过总线把访问请求送往主存(内存)，这毕竟是慢的。高速缓存的命中通常需要两个时钟周期。高速缓存为命中，就必须访问内存，这需要付出大量的时间代价。由于高速缓存价格昂贵，所以其大小有限，有些机器具有两级甚至三级高速缓存，每一级高速缓存比前一级慢但是容易大。
##### 主存：

再往下一层是**主存**，此乃存储器系统的主力，主存通常称为**随机访问存储RAM**，就是我们通常所说的**内存**，容量一直在不断攀升，所有不能再高速缓存中找到的，都会到主存中找，主存是**易失性存储**，断电后数据全部消失

######  ROM
除了主存RAM之外，许多计算机已经在使用少量的**非易失性随机访问存储**如**ROM**（Read Only Memory，ROM），在电源切断之后，非易失性存储的内容并不会丢失，**ROM**只读存储器在工厂中就被编程完毕，然后再也不能修改。**ROM**速度快且便宜，在有些计算机中，用于启动计算机的引导加载模块就存放在**ROM**中，另外一些I/O卡也采用ROM处理底层设备的控制。

###### EEPROM（Electrically Erasable PROM，电可擦除可编程ROM）和闪存（flash memory）
也是**非易失性**的，但是与ROM相反，他们可以擦除和重写。不过重写时花费的时间比写入RAM要多。在便携式电子设备中中，闪存通常作为存储媒介。闪存是数码相机中的胶卷，是便携式音译播放器的磁盘，还应用于固态硬盘。闪存在速度上介于RAM和磁盘之间，但与磁盘不同的是，闪存擦除的次数过多，就被磨损了。

###### CMOS
还有一类存储器就是**CMOS**，它是**易失性**的，许多计算机利用CMOS存储器来保持当前时间和日期。CMOS存储器和递增时间的电路由一小块**电池驱动**，所以，即使计算机没有加电，时间也仍然可以正确地更新，除此之外CMOS还可以保存配置的参数，比如，哪一个是**启动磁盘**等，之所以采用CMOS是因为它耗电非常少，一块工厂原装电池往往能使用若干年，但是当电池失效时，相关的配置和时间等都将丢失
####  硬盘  
#####  磁头  
是硬盘读取数据的关键部件，它的主要作用就是将存储在硬盘盘片上的磁信息转化为电信号向外传输。
#####  磁道：
磁头绕磁盘读取一圈的同心圆称为磁道
#####  扇区：
最小读取单位，扇区典型的值是512字节，磁道数据都存放于一段一段的扇区，即磁道这个圆圈的一小段圆弧，从磁盘读取一段数据需要经历寻道时间和延迟时间。
* 平均寻道时间  
机械手臂从一个柱面随机移动到相邻的柱面的时间成称为寻道时间，找到了磁道就意味着找到了数据所在的那个圆圈，但是还不知道数据具体这个圆圈的具体位置
* 平均延迟时间  
机械臂到达正确的磁道之后还必须等待旋转到数据所在的扇区下，这段时间成为延迟时间，最快下一刻就找到，最慢需要转一圈。
#####  柱面：
多个磁头读取的相同半径的磁道组合成柱面，两个柱面之间叫分区

#####  虚拟内存：
许多计算机支持虚拟内存机制，该机制使计算机可以运行大于物理内存的程序，方法是将正在使用的程序放入内存取执行，而暂时不需要执行的程序放到磁盘的某块地方，这块地方成为**虚拟内存**，在linux中成为**swap**，这种机制的核心在于快速地映射内存地址，由cpu中的一个部件负责，成为存储器管理单元(Memory Management Unit,MMU)
 
PS：从一个程序切换到另外一个程序，成为上下文切换(context switch),缓存和MMU的出现提升了系统的性能，尤其是上下文切换

swap分区一般是内存1.5-2倍  
#### 磁带
在价钱相同的情况下比硬盘拥有更高的存储容量，虽然速度低于磁盘，但是因其大容量，在地震水灾火灾时可移动性强等特性，常被用来做备份。（常见于大型数据库系统中）
#### I/O设备
cpu和存储器并不是操作系统唯一需要管理的资源，I/O设备也是非常重要的一环。  
最常见的I/O设备有打印机、硬盘、键盘和鼠标。严格意义上来讲，有一些只能算是输入设备（比如说键盘和鼠标）；有一些只是输出设备（如打印机）。
所有储存器也可以算是输入/输出设备。如硬盘、软盘、光盘等。
I/O设备一般包括两个部分：设备控制器和设备本身。  
* 设备控制器  
是查找主板上的一块芯片或一组芯片（硬盘，网卡，声卡等都需要插到一个口上，这个口连的便是控制器），控制器负责控制连接的设备，它从操作系统接收命令，比如读硬盘数据，然后就对硬盘设备发起读请求来读出内容。
* 设备驱动：通常情况下对设备的控制是非常复杂和具体的，控制器的任务就是为操作系统屏蔽这些复杂而具体的工作，提供给操作系统一个简单而清晰的接口要想调用设备，必须根据该接口编写复杂而具体的程序，于是有了控制器提供设备驱动接口给操作系统。

####  总线
但是随着处理器和存储器速度越来越快，单总线很难处理总线的交通流量了，于是出现了下图的多总线模式，他们处理I/O设备及cpu到存储器的速度都更快。  
![](http://images2015.cnblogs.com/blog/1036857/201701/1036857-20170118183358656-1969770652.png)
*  PCI桥（北桥）连接高速设备，如CPU、内存等  
*  ISA桥（南桥）连接慢速设备，如磁盘、声卡、键盘等
####  启动计算机

在计算机的主板上有一个基本的输入输出程序**BIOS**（Basic  Input Output system)，**BIOS**就相当于一个小的操作系统，它有底层的I/O软件，包括读键盘，写屏幕，进行磁盘I/O，该程序存放于一非易失性闪存ROM中。

* 启动流程：

1. 计算机加电

2. **BIOS**开始运行，检测硬件：cpu、内存、硬盘等

3. **BIOS**读取**CMOS**存储器中的参数，选择启动设备（系统启动盘）

4. 从启动设备（系统盘）上读取第一个扇区的内容：**MBR**（主引导记录），找到相应的**BootLoader**  
**MBR**：主引导记录，512字节，分成446字节，存储引导信息（引导信息指示**BootLoader** 程序），后64为分区信息，最后2个字节为标志位  

5. **BIOS**读入**BootLoader** 如grub，找到系统**kernel**代码并加载进内存，启动操作系统  
> grub：一种常见**BootLoader** ，可以会指示系统信息（操作系统在哪里）  

6. 启动操作系统**kernel**代码后，系统询问**BIOS**，以获得配置信息，检测驱动，初始化表格（如进程表），启动开启自启的软件。
> 对于每种设备，系统会检查其设备驱动程序是否存在，如果没有，系统则会要求用户按照设备驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始有关的表格（如进程表），穿件需要的进程，并在每个终端上启动登录程序或GUI

####  作业
1. 预习操作系统  
2. 默写：  
* 内核态和用户态  
* 计算机启动流程  
* 应用软件的启动流程   
启动快捷方式，操作系统收到启动请求和软件位置信息
系统切换CPU到内核态到磁盘相应位置读取软件启动文件
系统将启动文件加载进内存
内存交由CPU运算，CPU返回结果给系统
系统切换CPU至用户态，并将结果返回给用户软件，软件启动成功

####  总结：  
* part1：    
这是CPU的两种工作状态  
内核态：运行操作系统内核，可以操作硬件（可以获取所有CPU的指令集）  
用户态：运行应用程序，不可以操作硬件（可以获得所有CPU的指令集的一个子集，不包括操作硬件的指令）  
用户态和内核态的切换：  
* part2:  
**BIOS**：Basic Inuput Output System，硬盘--->CMOS  
**MBR**: 主引导记录512=446+64+2  
**BootLoader** :grub指示kernel代码  
**kernel**  
* part3  
应用程序的启动流程：
前提：应用程序是运行于操作系统之上的  
举例： 启动暴风影音  
双击快捷方式-->告诉操作系统一个文件路径  
--->操作系统从硬盘读取文件内容到内存中--->CPU从内存读取数据执行    